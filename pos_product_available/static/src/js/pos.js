odoo.define('pos_product_available.PosModel', function(require){
"use strict";


    var models = require('point_of_sale.models');
    var screen = require('point_of_sale.screens');
    var Model = require('web.DataModel');

    var PosModelSuper = models.PosModel.prototype;


    models.PosModel = models.PosModel.extend({
 
             load_server_data: function(){
            var self = this;

            var loaded = PosModelSuper.load_server_data.call(this);

            var set_prod_vals = function(vals) {
                _.each(vals, function(v){
                    _.extend(self.db.get_product_by_id(v.id), v);
                });
            };

            var prod_model = _.find(this.models, function(model){
                return model.model === 'product.product';
            });
            if (prod_model) {
                prod_model.fields.push('qty_available', 'type');
                var context_super = prod_model.context;
                prod_model.context = function(that){
                    var ret = context_super(that);
                    ret.location = that.config.stock_location_id[0];
                    return ret;
                };
                var loaded_super = prod_model.loaded;
                prod_model.loaded = function(that, products){
                    loaded_super(that, products);
                    set_prod_vals(products);
                };
                return loaded;
            }

            return loaded.then(function(){
                return new Model('product.product').query(['qty_available', 'type']).
                    filter([['sale_ok','=',true],['available_in_pos','=',true]]).
                    context({'location': self.config.stock_location_id[0]}).all().then(function(products){
                        set_prod_vals(products);
                    });
            });
        },
    

     
        refresh_qty_available:function(product){
            var $elem = $("[data-product-id='"+product.id+"'] .qty-tag");
            $elem.html(product.qty_available)
            if (product.type == 'product'){
                if (product.qty_available <= 0 && !$elem.hasClass('not-available')){
                    $elem.addClass('not-available')
                }
            }
        },
        push_order: function(order){
            var self = this;
            var pushed = PosModelSuper.push_order.call(this, order);
            if (order){
                order.orderlines.each(function(line){
                    var product = line.get_product();
                    if (product.type == 'product') {
                        product.qty_available -= line.get_quantity();
                        self.refresh_qty_available(product);
                    }
                })
            }
            return pushed;
        },
        push_and_invoice_order: function(order){
            var self = this;
            var invoiced = new $.Deferred();

            if(!order.get_client()){
                invoiced.reject({code:400, message:'Missing Customer', data:{}});
                return invoiced;
            }

            var order_id = this.db.add_order(order.export_as_JSON());

            this.flush_mutex.exec(function(){
                var done = new $.Deferred(); // holds the mutex

                // send the order to the server
                // we have a 30 seconds timeout on this push.
                // FIXME: if the server takes more than 30 seconds to accept the order,
                // the client will believe it wasn't successfully sent, and very bad
                // things will happen as a duplicate will be sent next time
                // so we must make sure the server detects and ignores duplicated orders

                var transfer = self._flush_orders([self.db.get_order(order_id)], {timeout:30000, to_invoice:true});

                transfer.fail(function(error){
                    invoiced.reject(error);
                    done.reject();
                });

                // on success, get the order id generated by the server
                transfer.pipe(function(order_server_id){
                    if (order && order.get_client()){
                        if (order.orderlines){
                            order.orderlines.each(function(line){
                                var product = line.get_product();
                                product.qty_available -= line.get_quantity();
                                self.refresh_qty_available(product);
                            });
                        }
                    }
                    // generate the pdf and download it
                    self.chrome.do_action('point_of_sale.pos_invoice_report',{additional_context:{
                        active_ids:order_server_id,
                    }});

                    invoiced.resolve();
                    done.resolve();
                });

                return done;

            });

            return invoiced;
        },
    });

})
